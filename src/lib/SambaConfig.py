### Useful for this file
### https://manpages.ubuntu.com/manpages/jammy/man5/smb.conf.5.html
### https://www.samba.org/samba/docs/current/man-html/smb.conf.5.html
### 
### Pay attention to
### https://manpages.ubuntu.com/manpages/jammy/man5/smb.conf.5.html#warnings

import re
import hashlib
import os
import shlex
import io
import configparser
import logging
from textwrap import dedent
from dataclasses import dataclass, field

from .ShellScript import ShellScript
from . import terminal, utils
from gi.repository import GLib  # noqa

@dataclass
class SambaShare:
    name: str
    share_path: str
    comment: str
    writeable: bool
    public: bool
    valid_users: list = field(default_factory=list)
    force_user: str | None = None

    @staticmethod
    def create_empty():
        return SambaShare(
            name='',
            share_path='',
            comment='',
            writeable=True,
            public=True,
            valid_users=[],
            force_user=None
        )

class SambaConfig():
    DEFAULT_GLOBAL_SECTION = {
        'workgroup': 'WORKGROUP',
        'server string': '%h server (Samba)',
        'server role': 'standalone server',
        'log file': '/var/log/samba/log.%m',
        'max log size': '1000',
        'logging': 'file',
        'map to guest': 'bad user',
        # Keep samba and unix users separated, makes everything easier
        'unix password sync': 'no',
        'pam password change': 'no',
        # Disable usershare to keep everything under control
        'usershare max shares': '0',
        'passwd chat': '"new password" %n\\n "retype new password" %n\\n "Password changed"'
    }
    REQUIRED_CLI_TOOLS = ['testparm', 'smbd', 'smbcontrol', 'smbstatus']
    RESERVED_SECTIONS = ['homes', 'printers', 'global', 'print$']
    COMMENTS_LINE_START = ['#', ';']
    REQUIRED_HEADER_LINE = '# - This configuration file was automatically generated by Simba -'
    CONFIG_FILE_HEADER = """
        #
        # - This configuration file was automatically generated by Simba -
        # A GUI tool to manage the Samba server.
        #
        # For addiitonal information about smb.com, please visit the following website:
        # https://www.samba.org/samba/docs/current/man-html/smb.conf.5.html
        #
        # For addiitonal information about Simba, please visit the following website:
        # https://github.com/mijorus/simba
        #
        #
        # If you still want to manager your server using Simba, 
        # do not remove the following lines.
        #
        # Hash: $file_hash
        #
    """

    def __init__(self, override_config_file_location=None) -> None:
        flatpak_prefix = '/var/run/host'
        self.config_file_location = '/etc/samba/smb.conf'
        self.sys_config_file_location = self.config_file_location
        self.tmp_config_file_location = GLib.get_user_cache_dir()

        if os.environ.get('container') == 'flatpak':
            self.config_file_location = flatpak_prefix +  self.config_file_location
            # self.tmp_config_file_location = flatpak_prefix + self.tmp_config_file_location

        if override_config_file_location:
            self.config_file_location = override_config_file_location

        self._config_file_content = ''
        self.data = configparser.ConfigParser(
            comment_prefixes=self.COMMENTS_LINE_START,
            inline_comment_prefixes=self.COMMENTS_LINE_START,
            strict=True,
            interpolation=None,
            default_section='global'
        )

        if os.path.exists(self.config_file_location):
            self._parse()

    @staticmethod
    def get_samba_version():
        smbv = terminal.host_sh(['smbd', '--version'])
        return smbv.replace('Version', '').strip().split('.')

    @staticmethod
    def test_compatibility():
        for tool in SambaConfig.REQUIRED_CLI_TOOLS:
            try:
                terminal.host_sh(['command', '-v', tool])
            except Exception as e:
                logging.warning('Missing required CLI tool: ' + tool)
                return False
        
        if SambaConfig.get_samba_version()[0] != '4':
            return False
        
        return True

    def is_config_supported(self):
        if self.REQUIRED_HEADER_LINE not in self._config_file_content:
            logging.warning('required header line not found')
            return False

        pattern = r'# Hash:\s*([a-fA-F0-9]{32})'
        match = re.search(pattern, self._config_file_content, re.MULTILINE)

        if not match:
            logging.warning('hash not found')
            return False

        stored_hash = match.group(1)
        current_hash = self.get_md5(file_path=self.config_file_location)

        if stored_hash != current_hash:
            logging.warning('hash do not match:')

        return stored_hash == current_hash

    def init_with_defaults(self):
        self.data.clear(    )
        self.data['global'] = self.DEFAULT_GLOBAL_SECTION

    def save(self):
        text_content = self._get_text_content()

        random_string = utils.get_random_md5()
        testfile_path = os.path.join(self.tmp_config_file_location, f'{random_string}.conf')
        config_file_hash = self.get_md5(content=text_content)
        text_header = dedent(self.CONFIG_FILE_HEADER).replace('$file_hash', config_file_hash)
        text_content = '\n'.join([text_header, text_content])

        with open(testfile_path, 'w+') as f:
            f.write(text_content)

        # check file validity
        terminal.host_sh(['testparm', '--suppress-prompt', testfile_path])

        save_script = ShellScript(
            path=os.path.join(self.tmp_config_file_location, 'save_samba_config.sh'),
            content="""
                set -e
                cp $location $location_old
                cp $testfile_path $location
                smbcontrol all reload-config
            """,
            testfile_path=testfile_path,
            location=self.sys_config_file_location,
            location_old=f'{self.sys_config_file_location}.simba.old'
        )

        save_script.root_host_execute()

        if os.path.exists(testfile_path):
            os.remove(testfile_path)

        save_script.delete()
        self._parse()

    def get_md5(self, file_path=None, content=''):
        if (not content) and (not file_path):
            raise Exception('Missing content and file_path')

        if file_path:
            with open(file_path, 'r') as f:
                content = f.read()

        valid_content = ''
        for line in content.split('\n'):
            skip_line = False
            line = line.strip()
            for s in self.COMMENTS_LINE_START:
                skip_line = (not line) or line.startswith(s)
                
                if skip_line:
                    break
            
            if not skip_line:
                valid_content += (line + '\n')

        filehash = hashlib.md5(valid_content.encode()).hexdigest()

        return filehash

    def get_section(self, section: str):
        return self.data[section]
    
    def create_section(self, section: str, data: dict):
        self.data[section] = data

    def check_valid_share_name(self, name: str) -> tuple:
        if name in self.RESERVED_SECTIONS:
            return (False, 'name reserved')
        
        if len(name) > 8:
            return (False, 'name is too long')
        
        return (True, '')

    def delete_share(self, share: SambaShare):
        if share.name not in self.data.keys():
            raise Exception(f'{share.name} does not exists! Available shares are: {self.data.keys()}')
        
        del self.data[share.name]

    def create_share(self, share: SambaShare):
        name_check, name_check_error = self.check_valid_share_name(share.name)
        if not name_check:
            raise Exception(f'{share.name}: ' + name_check_error)

        self.create_section(share.name, {
            'path': share.share_path,
            'writeable': share.writeable,
            'public': share.public,
            'browseable': True,
            'comment': share.comment,
            # we manually enforce 0644, default value would be 0755
            'create mask': '0644', 
            # we are just expliciting the permission here, as 0755 is already the default for new directories
            'directory mask': '0755', 
        })

    def list_shares(self) -> list[SambaShare]:
        shares = []
        for section, data in self.data.items():
            if f'{section}' in self.RESERVED_SECTIONS:
                continue

            writeable = data.getboolean('writeable', True)
            if 'read_only' in data:
                writeable = not data['read_only']

            share = SambaShare(
                name=section,
                share_path=data.get('path', ''),
                comment=data.get('comment', ''),
                writeable=writeable,
                public=data.getboolean('public', True)
            )

            shares.append(share)

        return shares

    @staticmethod
    def create_user(user, passwd):
        passwd_confirm = shlex.quote(f'{passwd}\\n{passwd}\\n')
        user = shlex.quote(user)

        command = f'echo -ne "{passwd_confirm}" | pdbedit --create --password-from-stdin {user}'
        terminal.host_sh(['pkexec', 'bash', '-c', command], hide_log=True)

    @staticmethod
    def list_users():
        data = terminal.host_sh(['pkexec', 'pdbedit', '--list'], hide_log=True)
        output = []

        for line in data.split('\n'):
            u, uid, comment = line.split(':')
            output.append({
                'user': u,
                'uid': uid,
                'comment': comment
            })

        return output


    def _get_text_content(self):
        # 1. Create the string buffer
        string_stream = io.StringIO()

        # 2. Write the config object into the buffer
        self.data.write(string_stream)

        # 3. Retrieve the string value
        config_string = string_stream.getvalue()
        return config_string

    def _parse(self):
        """Parse a smb file"""
        with open(self.config_file_location, 'r') as f:
            self._config_file_content = f.read()

        self.data.read(self.config_file_location)
